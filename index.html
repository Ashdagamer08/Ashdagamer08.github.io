<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
body {
  margin: 0;
  background: #0e0e0e;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  overflow: hidden;
  touch-action: none;  /* prevents  extermely annoying scrolling on mobile */
}
canvas {
  background: radial-gradient(circle at center, #1e1e1e, #0a0a0a);
  border: 2px solid #4caf50;
  box-shadow: 0 0 30px rgba(0,255,0,.4);
}
#pauseButton {
  position: absolute;
  top: 12px;
  right: 12px;
  padding: 10px 18px;
  font-size: 16px;
  background: #4caf50;
  color: white;
  border: none;
  border-radius: 6px;
  z-index: 10;
  cursor: pointer;
}
</style>
</head>

<body>
<button id="pauseButton">Pause</button>
<canvas id="game"></canvas>

<script>
// get the main elements - canvas and button //
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const pauseButton = document.getElementById("pauseButton");

let W, H;  // width and height variables //

// function handles screen resizing //
function resize() {
  const aspectRatio = 4 / 3;
  const maxWidth = innerWidth * 0.9;
  const maxHeight = innerHeight * 0.8;
  
  if (maxWidth / maxHeight > aspectRatio) {
    H = maxHeight;
    W = H * aspectRatio;
  } else {
    W = maxWidth;
    H = W / aspectRatio;
  }
  
  canvas.width = W;
  canvas.height = H;
  recalc();  // recalculate game dimensions //
}

addEventListener("resize", resize);

// game dimensions, these scale with canvas size //
let ballRadius, paddleWidth, paddleHeight, ballSpeedX, maxSpeedY, aiSpeed;

function recalc() {
  ballRadius = W * 0.016;
  paddleWidth = W * 0.025;
  paddleHeight = H * 0.24;
  ballSpeedX = W * 0.0065;
  maxSpeedY = H * 0.012;
  aiSpeed = H * 0.006;
}

resize();  // initial size calculation //

// ball position and velocity //
let ballX, ballY, ballDX, ballDY;

// paddle positions //
let player1Y, player2Y;

// scorez //
let score1 = 0;
let score2 = 0;

let isPaused = false;
let gameWon = false;
const WINNING_SCORE = 7;

// le effects //
let shakeAmount = 0;
let flashAmount = 0;

// power-ups array //
const powerUps = [];
const POWERUP_SIZE = W * 0.03;

// audio context for sound effects //
const audioContext = new AudioContext();
let isAudioUnlocked = false;

// audio unlock //
function unlockAudio() {
  if (!isAudioUnlocked) {
    audioContext.resume();
    backgroundMusic.start();
    isAudioUnlocked = true;
  }
}

// simple sound effect generator //
function playTone(frequency, duration, volume) {
  const oscillator = audioContext.createOscillator();
  const gainNode = audioContext.createGain();
  oscillator.frequency.value = frequency;
  oscillator.type = "sawtooth";
  gainNode.gain.value = volume;
  oscillator.connect(gainNode).connect(audioContext.destination);
  oscillator.start();
  oscillator.stop(audioContext.currentTime + duration);
}

// sound effects for different game events //
function playHitSound() {
  playTone(500, 0.05, 0.15);
}

function playScoreSound() {
  playTone(180, 0.2, 0.2);
}

function playPowerUpSound() {
  playTone(900, 0.15, 0.25);
}


const backgroundMusic = audioContext.createOscillator();
const musicVolume = audioContext.createGain();
backgroundMusic.type = "triangle";
backgroundMusic.frequency.value = 110;
musicVolume.gain.value = 0.04;  
backgroundMusic.connect(musicVolume).connect(audioContext.destination);


function resetBall(direction) {
  ballX = W / 2;
  ballY = H / 2;
  ballDX = ballSpeedX * direction;
  ballDY = (Math.random() * 2 - 1) * maxSpeedY * 0.6;
}

// Start a fresh game //
function resetGame() {
  score1 = 0;
  score2 = 0;
  gameWon = false;
  player1Y = H / 2 - paddleHeight / 2;
  player2Y = H / 2 - paddleHeight / 2;
  powerUps.length = 0;  // should be obvious //
  resetBall(Math.random() > 0.5 ? 1 : -1);
}

resetGame();

// spawn a random power-up //
function spawnPowerUp() {
  let type;
  const rand = Math.random();
  
  if (rand < 0.5) {
    type = "grow";
  } else if (rand < 0.75) {
    type = "shrink";
  } else {
    type = "speed";
  }
  
  powerUps.push({
    x: W / 2,
    y: Math.random() * (H - POWERUP_SIZE * 2) + POWERUP_SIZE,
    type: type
  });
}


setInterval(() => {
  if (!gameWon && Math.random() < 0.6) {
    spawnPowerUp();
  }
}, 6000);

let isPointerActive = false;


canvas.addEventListener("pointerdown", e => {
  unlockAudio();
  isPointerActive = true;
  canvas.setPointerCapture(e.pointerId);
  
  // restart game if it's over
  if (gameWon) {
    resetGame();
  }
});

canvas.addEventListener("pointermove", e => {
  if (!isPointerActive) return;
  
  const rect = canvas.getBoundingClientRect();
  player1Y = e.clientY - rect.top - paddleHeight / 2;
  
  
  player1Y = Math.max(0, Math.min(H - paddleHeight, player1Y));
});

canvas.addEventListener("pointerup", e => {
  isPointerActive = false;
  canvas.releasePointerCapture(e.pointerId);
});


pauseButton.addEventListener("pointerdown", e => {
  unlockAudio();
  isPaused = !isPaused;
  pauseButton.textContent = isPaused ? "Resume" : "Pause";
});


function update() {
  if (isPaused || gameWon) return;

  
  ballX += ballDX;
  ballY += ballDY;

  // ball collision with top/bottom walls //
  if (ballY < ballRadius || ballY > H - ballRadius) {
    ballDY *= -1;
    playHitSound();
  }

  
  if (ballX - ballRadius < paddleWidth && ballY > player1Y && ballY < player1Y + paddleHeight) {
    ballDX = Math.abs(ballDX) * 1.08;  // zoom zoom zoom! //
    ballDY = ((ballY - (player1Y + paddleHeight / 2)) / (paddleHeight / 2)) * maxSpeedY;
    playHitSound();
    shakeAmount = 6;
    flashAmount = 4;
  }

  // ball collision with ai paddle, right side //
  if (ballX + ballRadius > W - paddleWidth && ballY > player2Y && ballY < player2Y + paddleHeight) {
    ballDX = -Math.abs(ballDX) * 1.08;
    ballDY = ((ballY - (player2Y + paddleHeight / 2)) / (paddleHeight / 2)) * maxSpeedY;
    playHitSound();
    shakeAmount = 6;
    flashAmount = 4;
  }

  
  if (ballX < 0) {
    score2++;
    playScoreSound();
    resetBall(1);
  }
  
  if (ballX > W) {
    score1++;
    playScoreSound();
    resetBall(-1);
  }

  
  const aiPaddleCenter = player2Y + paddleHeight / 2;
  if (aiPaddleCenter < ballY - 25) {
    player2Y += aiSpeed;
  } else if (aiPaddleCenter > ballY + 25) {
    player2Y -= aiSpeed;
  }
  
  player2Y = Math.max(0, Math.min(H - paddleHeight, player2Y));

  // check for powerup collisions //
  for (let i = powerUps.length - 1; i >= 0; i--) {
    const powerUp = powerUps[i];
    const distance = Math.hypot(ballX - powerUp.x, ballY - powerUp.y);
    
    if (distance < ballRadius + POWERUP_SIZE / 2) {
      // apply powerup effect //
      if (powerUp.type === "grow") {
        paddleHeight *= 1.25;
      }
      if (powerUp.type === "shrink") {
        paddleHeight *= 0.8;
      }
      if (powerUp.type === "speed") {
        ballDX *= 1.3;
        ballDY *= 1.3;
      }
      
      playPowerUpSound();
      powerUps.splice(i, 1);
    }
  }

  // score again //
  if (score1 >= WINNING_SCORE || score2 >= WINNING_SCORE) {
    gameWon = true;
  }
}

function draw() {
  ctx.save();
  
  // screen shake effect when ball hits paddle :3 //
  if (shakeAmount) {
    ctx.translate(
      (Math.random() - 0.5) * shakeAmount,
      (Math.random() - 0.5) * shakeAmount
    );
    shakeAmount--;
  }
  
  ctx.clearRect(0, 0, W, H);

  // flash effect on paddle hit //
  if (flashAmount) {
    ctx.fillStyle = "rgba(255, 255, 255, 0.15)";
    ctx.fillRect(0, 0, W, H);
    flashAmount--;
  }

  // draw ball with glow effect //
  ctx.fillStyle = "#4caf50";
  ctx.shadowBlur = 15;
  ctx.shadowColor = "#4caf50";
  ctx.beginPath();
  ctx.arc(ballX, ballY, ballRadius, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // draw paddles //
  ctx.fillStyle = "#fff";
  ctx.fillRect(0, player1Y, paddleWidth, paddleHeight);
  ctx.fillRect(W - paddleWidth, player2Y, paddleWidth, paddleHeight);

  // draw powerups //
  for (const powerUp of powerUps) {
    if (powerUp.type === "grow") {
      ctx.fillStyle = "#00e5ff";
    } else if (powerUp.type === "shrink") {
      ctx.fillStyle = "#ff1744";
    } else {
      ctx.fillStyle = "#ffd600";
    }
    
    ctx.beginPath();
    ctx.arc(powerUp.x, powerUp.y, POWERUP_SIZE / 2, 0, Math.PI * 2);
    ctx.fill();
  }

  // draw scores //
  ctx.font = `${H * 0.08}px Arial`;
  ctx.fillStyle = "#4caf50";
  ctx.fillText(score1, W * 0.25, H * 0.1);
  ctx.fillText(score2, W * 0.75, H * 0.1);

  // game over screen //
  if (gameWon) {
    ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
    ctx.fillRect(0, 0, W, H);
    ctx.fillStyle = "#fff";
    
    const winnerText = score1 > score2 ? "You Win!" : "AI Wins!";
    ctx.fillText(winnerText, W / 2 - 110, H / 2);
    
    ctx.font = `${H * 0.04}px Arial`;
    ctx.fillText("Tap to Restart", W / 2 - 80, H / 2 + 40);
  }

  ctx.restore();
}

function gameLoop() {
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

gameLoop();
</script>
</body>
</html>
